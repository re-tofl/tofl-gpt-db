формальные определения LR(k)-грамматик
________________________________________________________________

Определение:
```
Пусть Γ=⟨Σ,N,E,P⟩ — контекстно-свободная грамматика. Пополненной грамматикой (англ. augmented grammar), полученной из Γ, назовем грамматику Γ′=⟨Σ′,N′,E0,P′⟩, где Σ′=Σ;N′=N∪{E0};E0∉N;P′=P∪{E0→E}
```
```
Определение:
Пусть Γ′=⟨Σ′,N′,E0,P′⟩— пополненная грамматика для КС-грамматики Γ. Грамматика Γ является LR(k)-грамматикой, если из того, что для любых двух правосторонних выводов верно, что:
    E0⇒∗βAtz⇒βαtz⇒∗w, если |t|=k или |t|<k,|z|=0(z=ε)
    E0⇒∗γBtz′⇒γξtz′⇒∗w′,если |t|=k или |t|<k,|z′|=0(z′=ε) 
следует, что βα=γξ ,
тогда β=γ и A=B
.
```
Говоря неформально, мы делаем правостороннюю свёртку нашей строки в стартовый нетерминал. Если по не более чем k символам неразобранной части строки мы можем однозначно определить, во что сворачивается хвост выведенного правила, то грамматика будет LR(k).

LR(k) означает, что:
    входная цепочка обрабатывается слева направо (англ. left-to-right parse),
    выполняется правый вывод (англ. rightmost derivation),
    для принятия решения используется не более k символов цепочки (англ. k-token lookahead).
================================================================
Гарранитрует ли  LR(k)-грамматика однозначность разбора ?
________________________________________________________________
Любая LR(k)-грамматика по определению гарантирует
однозначный разбор при определённой длине
lookahead-строки, поэтому ни одна грамматика с
неоднозначным разбором не является LR(k) ни для какого
значения k.
================================================================
Лемма о накачке для DCFL
________________________________________________________________
Пусть L — DCFL. Тогда существует такая длина накачки p,
что для всех пар слов w, w′ ∈ L, таких что
w = xy & w′ = xz, |x| > p и первые буквы y, z совпадают,
выполнено одно из двух:
1 существует накачка только префикса x (в привычном
смысле);
2 """
существует разбиение x = x1x2x3, y = y1y2y3,
z = z1z2z3 такое, что |x2x3| ⩽ p, |x2| > 0, и
∀i(x1(x2)^i x3y1(y2)^i y3 ∈ L & x1x2^ix3z1z2^iz3 ∈ L).
"""
================================================================
Степень недетерминизма языка
________________________________________________________________
Если PDA A допускает декомпозицию на DPDA, между
которыми есть максимум k недетерминированных
переходов, но не допускает такую декомпозицию при i < k
переходов, скажем, что A задаёт КС-язык с
k-недетерминированностью
================================================================
Исправление недетерминированности КС языка
________________________________________________________________
Пусть L — недетерминированный КС-язык и k > 0. Язык L
— k-исправляемый, если существует алфавит ∆, ∆ ∩ Σ = ∅
и DCFL L(k) ⊆ (Σ ∪ ∆)∗ такой, что для h(∆) = ε,
h(L(k)) = L и все слова языка L(k) содержат не больше k
букв из ∆.

Язык L имеет k-ую степень недетерминизма ⇔ L
k-исправляемый, но не k − 1-исправляемый.
================================================================
Переключающиеся автоматы (Alternating Finite Automata)
________________________________________________________________
Переключающиеся автоматы (Alternating Finite Automata)
содержат узлы двух типов: конъюнктивные и дизъюнктивные
(∀-узлы и ∃-узлы, соответственно).

Все AFA языки регулярные, т.к. регулярные языки
замкнуты относительно пересечений.

Позволяют легко моделировать lookahead-выражения
под итерацией, или lookahead-выражения внутри
lookahead-выражений. Например, автомат 
(a | b(? = (b∗ab∗a)∗b∗$))∗.
================================================================
Теоретический коллапс линейных парсеров
________________________________________________________________
Теорема:
Для всякого языка из класса DCFL существует
распознающая его SLR(1)-грамматика.
Следует из теоремы:
Для всякого языка из класса DCFL существует
распознающая его LR(k)-грамматика.

Теорема о том, что для любого языка из класса DCFL (Deterministic Context-Free Languages) существует распознающая его SLR(1)-грамматика, действительно важна в теории формальных языков и автоматов. Она утверждает, что можно построить детерминированный парсер для языков, которые могут быть описаны с помощью контекстно-свободных грамматик.
================================================================
автомат Треллиса
________________________________________________________________
Если переписывание стартует с «листьев», но структурой
является сеть, то получается т.н. «автомат Треллиса».
Языки, распознаваемые такими автоматами, — это в точности
линейные конъюнктивные языки.
Преобразование автомата Треллиса в конъюнктивную
грамматику (она будет линейной, т.к. в каждой базисной правой
части может быть, самое большее, всего один нетерминал):
S → Afinal
Ainit(a) → a, a ∈ Σ
Aδ(q1,q2) → Aq1 c & bAq2 , ∀b, c ∈ Σ
================================================================
Jumping Lemma
________________________________________________________________
k − MFA детерминированный, если
∀q ∈ Q, b ∈ Σ(| $$\bigcup_{i=1}^{k}  δ(q, i)$$|
 + |δ(q, b)| ⩽ 1). DMFL —
такой язык, для которого существует DMFA

Язык L ∈REGEX детерминированный, если либо он
является регулярным, либо ∀m∃n, pn, vn такие, что n ⩾ m,
pn, vn ∈ Σ+, причём:
|vn| = n;
vn — подслово pn;
pnvn — префикс какого-то слова из L ;
∀u ∈ Σ+(pnu ∈ L ⇒ vn — префикс u).
================================================================
Атрибутные грамматики
________________________________________________________________
Пусть A0 → A1 . . . An — правило КС-грамматики. Припишем к
нему конечное число атрибутных свойств.
Синтетические атрибуты вычисляются для A0 по атрибутам
A1,. . . ,An;
Наследуемые атрибуты вычисляются для Ai по атрибутам
A0,. . . , Ai−1,Ai+1,. . . ,An. Обычно — по атрибутам A0 и A1,
. . . , Ai−1 (левосторонние атрибутные грамматики).
Повторные нетерминалы при присвоении атрибутов
индексируются по вхождениям в правило слева направо. Т.е.,
например, если дано правило N → N − N, тогда уравнение на
атрибуты N0.attr = N1.attr − N2.attr будет означать, что
атрибут родителя есть атрибут левого потомка минус атрибут
правого потомка, помеченных нетерминалами N.
Неповторные нетерминалы в уравнениях на атрибуты обычно не
индексируются

Пример АГ для {anbncn}
Атрибут нетерминала iter семантически означает число
итераций. Чтобы не смешивать синтетические и наследуемые
атрибуты, введём также атрибут inh_iter, означающий то же
самое, но наследуемый сверху вниз по дереву разбора, а не снизу
вверх. Здесь == — предикат; := — операция присваивания.
Синтетический вариант:
S → AT ; T .iter == A.iter
A → aA ; A0.iter := A1.iter + 1
A → ε ; A.iter := 0
T → bT c ; T0.iter := T1.iter + 1
T → ε ; T .iter := 0
Вариант с наследованием:
S → AT ; B.inh_iter := A.iter
A → aA ; A0.iter := A1.iter + 1
A → ε ; A.iter := 0
T → bT c ; T1.inh_iter := T0.inh_iter − 1
T → ε ; T .inh_iter == 0
================================================================
Замкнута ли DMFL относительно пересечения с регулярным языком
________________________________________________________________
Замкнуты относительно пересечения с регулярным языком, а
также относительно дополнения, но только если разрешается
вводить неудачные переходы по обратным ссылкам;
================================================================
Замкнута ли DMFL относительно объединения
________________________________________________________________
Не замкнуты относительно объединения (и даже —
объединения с регулярными языками), и относительно
пересечения друг с другом.
